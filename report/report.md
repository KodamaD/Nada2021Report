# ハッシュテーブルの実装と計測

## 0. はじめに

プログラミング言語 C++ には、標準ライブラリに std::unordered_map としてハッシュテーブルが実装されている。しかし、std::unordered_map は要素へのポインタや参照を変化させてはならないという規格に基づいて実装されているため[^1]、オーバーヘッドが生じ、実行時間が遅いという問題がある。本稿では、複数の種類のハッシュテーブルを実装し、それらと std::unordered_map の性能を計測・比較する。

## 1. 導入

### 1.0. 計算量

**計算量**は、アルゴリズムの効率を評価するための尺度であり、**ランダウ記法**を用いて「入力サイズ $n$ に対し、このアルゴリズムは時間計算量 $O(n)$ で動作する」のように記述される。

### 1.1. 連想配列

プログラミングにおいて、複数の要素の列を扱うためには**配列**が用いられる。
配列は非負整数を添字とするが、この添字として非負整数以外のデータ型も用いることのできるデータ構造を**連想配列**、あるいは**辞書**という。添字として用いるデータ型を **key**、要素とするデータ型を **value** と呼ぶ。

連想配列は、以下の三つの機能を実現する。

- **insert** : 指定した key に対し、value を指定した値で紐づける。
- **erase** : 指定した key と、それに紐づいた value の組を削除する。
- **find** : 指定した key に紐づいた value の値を得る。指定した key が含まれていない場合は、そのことを報告する。

配列に key と value の組をそのまま格納することで、最悪計算量 $\Theta (n)$ で三つの操作を実現することができる。しかし、$n$ 個の要素を挿入するのに最悪 $\Theta (n^2)$ の計算量を要し、大きなサイズのデータを扱うためには現実的でない。

### 1.2. ハッシュテーブル

ハッシュテーブルは連想配列の一種である。key を**ハッシュ関数** $h$ によってある区間 $[0, n)$ に属する整数に変換し、value を大きさ $n$ の配列に格納することで機能を実現することができる。

しかし、用いるハッシュ関数の種類によっては、異なる二つの key が同じ整数に変換されることがある（これを**衝突**という）。衝突に対処する方法は様々であり、本稿でもいくつかの方法を実装する。

## 2. ハッシュテーブルを実現する手法

### 2.0. 連鎖法

**連鎖法（Chaining）**[^2] は、同じハッシュ値を持つ key と対応する value の組を全て同じリストに格納する。要素数が $m$ のとき、リストの個数 $n$ は $n \geq m$ を満たすようにすることで、リストの平均要素数が $1$ 以下となる。insert、erase、find の操作は、key $x$ のハッシュ値 $h(x)$ に対応するリスト内を線形探索することで実現することができる。

insert 操作によって $n < m$ となってしまった場合、リストの個数を $2$ 倍に増やし、全ての要素のハッシュ値を計算し直し、もう一度リストに入れ直す。$m$ 要素を insert するときに要する再計算の計算量の合計は $O(m)$ となる。

ハッシュ関数の性能が悪い場合、全ての要素が同じリストに格納されることになり、操作に $\Theta (m)$ の計算量を要する。高速に動作するためには、以下の条件を満たすハッシュ関数を用いるのが理想的である :

- $x, y$ が二つの異なる key であるとき、$h(x) = h(y)$ となる確率は十分小さい定数 $c$ を用いて $\displaystyle \frac{c}{n}$ と表される。

このハッシュ関数を用いたとき、任意の key $x$ に対し、$h(x)$ に対応するリストの要素数の期待値は $\displaystyle \frac{cm}{n} \leq c$ で抑えられるため、$c$ が定数であることから操作を $O(1)$ で実現することができる。

### 2.1. 開番地法

**開番地法（Open Addressing）**[^2] は、要素を直接長さ $n$ の配列に格納する。新たな key $x$ を insert する際に $h(x)$ に対応する場所にすでに値が格納されていた場合は、その近傍を探索し、空いている場所を探す。近傍を探索するにあたっては、$h(x)$ に対応する場所から $1$ ずつ増やす方法をとり、これを **線形探索法（Linear Probing）** という。配列には、次の三つの種類の値を格納する :

- その位置に値が格納されている場合、key と value の組
- その位置に格納された値が削除された場合、そのことを表す特別な値 del
- その位置には何も格納されず、削除もされていない場合、そのことを表す特別な値 null

h(x) からはじめ、null を見つけるまで探索したとき、途中で key が $x$ であるような組が見つかった場合、ハッシュテーブルには key が $x$ であるような値が存在する。そうでない、すなわち null が見つかった場合は、ハッシュテーブルには key が $x$ であるような値は存在しない。このことを用いると、insert、erase、find の三つの操作を実現することができる。

配列の長さ $n$ は、null 以外の値の個数を $m$ として、$\displaystyle \frac{3}{2} n \leq m$ となるようにとる。条件を満たさなくなった場合は、連鎖法と同様に、配列の長さを $2$ 倍に増やして要素を格納し直す。

開番地法には、衝突確率が低かったとしても、配列の連続した部分に要素が格納された場合、null にたどり着くまでの探索に長い時間がかかるという問題がある。ハッシュ値が $[0, n)$ に属する整数値を一様かつ独立にとるという強い仮定のもとで、三つの操作は計算量 $O(1)$ で実現することができる。

### 2.2. ハッシュ関数の選択

ハッシュ関数は、衝突確率が十分低くなるように key を $[0, n)$ に属する整数に変換する必要がある。このような条件を満たす関数を簡単に定義できるようにするため、本稿では二つの簡略化を行う。まず、2.1 と 2.2 で紹介した手法では、$n$ の値は必要に応じて $2$ 倍にするのみであるため、$n = 2^d$ となる非負整数 $d$ が存在すると仮定することができる。さらに、ハッシュ関数を次の二つのステップに分ける。

- $f(x)$ : key $x$ を $[0, 2^{64})$ に属する整数 $k$ に変換する。
- $g(k)$ : $[0, 2^{64})$ に属する整数 $k$ を $[0, 2^d)$ に属する整数 $l$ に変換する。

一つ目のステップでは、衝突が起こってしまった場合、異なる key が同じものであるとみなされてしまい、ハッシュテーブルが正常に動作しない。これは、処理時間が遅くなる以上の問題であるため、衝突を防ぐことは最も重要な課題となる。
二つ目のステップは、衝突確率がハッシュテーブルの処理時間に影響する。用いる手法に適した関数を選択することが重要となる。

一つ目のステップは、key とするデータ型によって使用する関数が大きく異なり、これはハッシュテーブルを使用するユーザに依存する。そのため本稿では、二つ目のステップのみを実装する。

#### 2.2.0. Multiplicative Hashing

**Multiplicative Hashing** は、$[0, 2^{64})$ に属する奇数をランダムに選び $p$ とおいたとき、$\displaystyle g(k) = \left\lfloor \frac{pk \bmod 2^{64}}{2^{64-d}} \right\rfloor$ とする方法である。異なる二つの整数 $k_1, k_2$ に対し $g(k_1) = g(k_2)$ となる確率は $\displaystyle \frac{2}{2^d}$ である[^2]。

#### 2.2.1. Fibonacci Hashing

Multiplicative Hashing において、$\phi$ を黄金比として $\displaystyle \frac{2^{64}}{\phi}$ に近い値を $p$ として選ぶ（$p = 11400714819323198485$）と、得られる値が一様に分布するという性質がある[^3]。

これらの方法に共通する問題点は、入力の上位ビットの情報が失われやすいことである[^3]。
そこで、$pk$ の代わりに $k$ と $\displaystyle \left\lfloor \frac{k}{2^{64-d}} \right\rfloor$ の排他的論理和と $p$ の積を採用することで、上位ビットの情報を反映することができる。本稿では、この工夫を施した Fibonacci Hashing を使用する。

## 3. 設計と実装

2.2 で述べたように、データ型を整数に変換する処理はユーザに依存するため、key としては $64$ ビット整数を利用する。

ハッシュテーブルのインターフェイスとして、insert、erase、find 関数を実装する。

## 4. 計測と比較

## 5. 結論

[^1]: "Working Draft, Standard for Programming Language C++"（<http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf>）
[^2]: Pat Morin（著）、堀江慧・陣内佑・田中康隆（訳）『みんなのデータ構造』ラムダノート株式会社 2018 年
[^3]: Malte Skarupke "Fibonacci Hashing: The Optimization that the World Forgot (or: a Better Alternative to Integer Modulo)"（<https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/>）
